/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "ssd1306.h"
#include "ssd1306_tests.h"
#include "ssd1306_fonts.h"
#include <string.h>

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c2;
ADC_HandleTypeDef hadc1;
UART_HandleTypeDef huart2;
UART_HandleTypeDef huart3;
UART_HandleTypeDef huart4;

/* USER CODE BEGIN PV */
HAL_StatusTypeDef UART2_CHECK;
HAL_StatusTypeDef UART3_CHECK;

#define UART_BUFFER_LENGTH 10
#define UART_EXPECT_DATA_SIZE 1
#define LED2_KIT_PORT GPIOB
#define LED2_KIT_PIN GPIO_PIN_15
#define LED1_KIT_PORT GPIOA
#define LED1_KIT_PIN GPIO_PIN_11
#define LED_UC_PORT GPIOA
#define LED_UC_PIN GPIO_PIN_5
#define BUTTON_PORT GPIOC
#define BUTTON_PIN GPIO_PIN_13
#define ADC_PIN GPIO_PIN_4

typedef enum
{
  NO_ERROR = 0,
  USART2_ERROR,
  USART3_ERROR,
  UART4_ERROR
} Status_Uart_t;

typedef enum
{
	NO_LOGGING_ERROR = 0,
	LOGGING_ERROR = 1
} Status_Logging_t;


typedef struct {
    uint8_t rx_buffer[UART_BUFFER_LENGTH];
    uint8_t tx_buffer[UART_BUFFER_LENGTH];
} UART_Data_t;

typedef struct{
	uint16_t temperature;
} ADC_Value_Temperature_t;

typedef struct{
	uint8_t index_tx;
	uint8_t intex_rx;
} INDEX_Of_Buffers_t;

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_USART3_UART_Init(void);
static void MX_UART4_Init(void);
static void MX_I2C2_Init(void);
static void MX_ADC1_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/

/* USER CODE BEGIN 0 */


UART_Data_t uart2_data;
UART_Data_t uart3_data;
UART_Data_t uart4_data;
Status_Uart_t uart_error_status = NO_ERROR;
Status_Logging_t logging = NO_LOGGING_ERROR;
HAL_StatusTypeDef moj_status;


Status_Logging_t Login_Write(const char* message) {
    /*  We will send via UART4 for logging messages  */
    moj_status = HAL_UART_Transmit(&huart4, (uint8_t*)message, strlen(message), HAL_MAX_DELAY);

    return logging;
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_UART4_Init();
  MX_USART2_UART_Init();
  MX_USART3_UART_Init();
  MX_I2C2_Init();
  MX_ADC1_Init();

  /* USER CODE BEGIN 2 */

  if (ssd1306_Init()!= INITIALIZED_OLED_INIT_SUCCESSFULLY){
	  Login_Write("Unaible to initialize ssd1306 Init! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully initialized ssd1306 Init! \r\n");
  }


  /*  Enabling communications  */
  if (HAL_UART_Receive_IT(&huart2, uart2_data.rx_buffer, UART_EXPECT_DATA_SIZE) != HAL_OK){
	  Login_Write("Unaible to start UART2 receive IT MODE! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully started UART2 receive IT MODE! \r\n");
  }
  if(HAL_UART_Receive_IT(&huart3, uart3_data.rx_buffer, UART_EXPECT_DATA_SIZE) != HAL_OK){
	  Login_Write("Unaible to start UART3 receive IT MODE! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully started UART3 receive IT MODE! \r\n");
  }

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
	  //ssd1306_TestAll();
	  //HAL_GPIO_TogglePin(LED1_KIT_PORT, LED1_KIT_PIN);
	  //HAL_Delay(200);
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

	/* Callback function for EXTI13
	   This will start conversion for ADC1_IN9
   	   and end of that will display Temp on OLED
   	*/
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{

    if(GPIO_Pin == BUTTON_PIN) {
    	/* Inicijalizacija ADC-a */
    	if (HAL_ADC_Start_IT(&hadc1) != HAL_OK){ // Starts ADC -> we will catch the complete
    		Error_Handler();
    	}
    }
    else{
    	Login_Write("Not expected another interrupt only PC13! \r\n");
    }
}

/*  This function will get the temp value and send on display via I2C  */
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
    if (hadc->Instance == ADC1)
    {
        		/*  Catching the adc_value  */
    	uint32_t adc_value = HAL_ADC_GetValue(hadc);
    	ADC_Value_Temperature_t value;
    	value.temperature = (adc_value * 3.3 / 4095) * 100; // Example for a temperature sensor
    	char temp_str[20];
    	sprintf(temp_str, "Temp: %d C", value.temperature); // @suppress("Float formatting support")
    	//ssd1306_Clear();
    	if (ssd1306_SetCursor(0,0)!= INITIALIZED_OLED_CURSOR_SUCCESSFULLY){
    		Login_Write("Unaible to initialize ssd1306 SetCursor! \r\n");
    		Error_Handler();
    	}
    	else{
    		Login_Write("Successfully initialized ssd1306 SetCursor! \r\n");
    	}

    	char result = ssd1306_WriteString(temp_str, Font_7x10, White);
    	if (result == '\0') {
    	    Login_Write("Successfully initialized SSD1306 WriteString!\r\n");
    	}
    	else {
    	    Login_Write("Unable to initialize SSD1306 WriteString!\r\n");
    	    Error_Handler();
    	}
    	if (ssd1306_UpdateScreen()!= INITIALIZED_OLED_UPDATE_SCREEN_SUCCESSFULLY){
    		Login_Write("Unaible to initialize ssd1306 UpdateScreen! \r\n");
    		Error_Handler();
    	}
    	else{
    		Login_Write("Successfully initialized ssd1306 UpdateScreen! \r\n");
    	}


    }
    else{
    	Login_Write("Not hadc->Instance == ADC1! \r\n");
    	Error_Handler();
    }
}




	/* This is a bridge communication between HOST -> uC -> ESP8226 module */
					/*  This is for internet communication  */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{

  /*Define variables for index in array of buffers*/
  INDEX_Of_Buffers_t index = {0,0};

  //TODO Proveri sa profesorom zasto se ne uspostavlja konekcija sa esp8226 kako god se zove xd
  if (huart->Instance == USART2){
	  uart3_data.tx_buffer[index.index_tx] = uart2_data.rx_buffer[index.index_rx]; //Received by host and prepare to send to ESP module
	  UART2_CHECK = HAL_UART_Receive_IT(&huart2, uart2_data.rx_buffer[index.index_rx++], UART_EXPECT_DATA_SIZE);
	  HAL_UART_AbortTransmit_IT(&huart3); //Received data deleted, but prepared will be send
	  UART3_CHECK = HAL_UART_Transmit_IT(&huart3, uart3_data.tx_buffer[index.index_tx++], UART_EXPECT_DATA_SIZE);
	  if (UART2_CHECK != HAL_OK)
	  {
		  uart_error_status = USART2_ERROR; //USART2 ima gresku
		  Error_Handler();
	  }
	  else if (UART3_CHECK != HAL_OK)
	  {
		  uart_error_status = USART3_ERROR; //USART3 ima gresku
		  Error_Handler();
	  }


  }
  else if(huart->Instance == USART3) {
	  index.index_tx = index.index_rx = 0;
	  uart2_data.tx_buffer[index.index_tx] =  uart3_data.rx_buffer[index.index_rx]; //Received by ESP module and prepare to send to host
	  UART3_CHECK = HAL_UART_Receive_IT(&huart3, uart3_data.rx_buffer[index.index_rx++], UART_EXPECT_DATA_SIZE);
	  HAL_UART_AbortTransmit_IT(&huart2); //Received data deleted, but prepared will be send
	  UART2_CHECK = HAL_UART_Transmit_IT(&huart2, uart2_data.tx_buffer[index.index_tx++], UART_EXPECT_DATA_SIZE);

	  if (UART2_CHECK != HAL_OK)
	  {
		  uart_error_status = USART2_ERROR; //USART2 ima gresku
		  Error_Handler();
	  }
	  else if (UART3_CHECK != HAL_OK)
	  {
		  uart_error_status = USART3_ERROR; //USART3 ima gresku
		  Error_Handler();
	  }
  }

  else{
	  Login_Write("Not huart->Instance == USART2/USART3! \r\n");
	  Error_Handler();
  }
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
//	  Login_Write("Unaible to initialize RCC ControlVoltageScaling! \r\n");
	  Error_Handler();
  }


  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
	  Login_Write("Unaible to initialize RCC OscConfig! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully initialized RCC OscConfig! \r\n");
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
//	  Login_Write("Unaible to initialize RCC ClockConfig! \r\n");
	  Error_Handler();
  }

}

/**
  * @brief I2C2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C2_Init(void)
{

  /* USER CODE BEGIN I2C2_Init 0 */

  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
  hi2c2.Init.Timing = 0x00000003;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  {
	  Login_Write("Unaible to initialize I2C2 peripherial! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully initialized I2C2 peripherial! \r\n");
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
  {
	  Login_Write("Unaible to initialize I2C2 Analog filter! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully initialized I2C2 Analog filter! \r\n");
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
  {
	  Login_Write("Unaible to initialize I2C2 Digital filter! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully initialized I2C2 Digital filter! \r\n");
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}



/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  hadc1.Init.LowPowerAutoWait = DISABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.NbrOfConversion = 1;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.DMAContinuousRequests = DISABLE;
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc1.Init.OversamplingMode = DISABLE;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
	  Login_Write("Unaible to initialize ADC1 Init! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully initialized ADC1 Init! \r\n");
  }
  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
  {
	  Login_Write("Unaible to initialize ADC1 MultiModeConfigChannel! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully initialized ADC1 MultiModeConfigChannel! \r\n");
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_9;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
	  Login_Write("Unaible to initialize ADC1 ConfigChannel! \r\n");
	  Error_Handler();
  }
  else{
	  Login_Write("Successfully initialized ADC1 ConfigChannel! \r\n");
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;

  if (HAL_UART_Init(&huart2) != HAL_OK){
  	  Login_Write("Unaible to initialize UART2 peripherial! \r\n");
      Error_Handler();
    }
  else{
  	  Login_Write("Successfully initialized UART2 peripherial! \r\n");
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart3) != HAL_OK)
    {
  	  Login_Write("Unaible to initialize UART3 peripherial! \r\n");
      Error_Handler();
  }
  else{
  	  Login_Write("Successfully initialized UART3 peripherial! \r\n");
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}


/**
  * @brief UART4 Initialization Function
  * @param None
  * @retval None
  */


static void MX_UART4_Init(void)
{

  /* USER CODE BEGIN UART4_Init 0 */

  /* USER CODE END UART4_Init 0 */

  /* USER CODE BEGIN UART4_Init 1 */

  /* USER CODE END UART4_Init 1 */
  huart4.Instance = UART4;
  huart4.Init.BaudRate = 115200;
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
  huart4.Init.StopBits = UART_STOPBITS_1;
  huart4.Init.Parity = UART_PARITY_NONE;
  huart4.Init.Mode = UART_MODE_TX_RX;
  huart4.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart4.Init.OverSampling = UART_OVERSAMPLING_16;
  huart4.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart4.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart4) != HAL_OK)
  {
	  Login_Write("Unaible to initialize UART4 peripherial! \r\n");
      Error_Handler();
  }
  else{
	  Login_Write("Successfully initialized UART4 peripherial! \r\n");
  }
  /* USER CODE BEGIN UART4_Init 2 */

  /* USER CODE END UART4_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  HAL_StatusTypeDef gpio_status = HAL_ERROR; // Definiši statusnu promenljivu
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_UC_PORT, LED_UC_PIN|LED1_KIT_PIN, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED2_KIT_PORT, LED2_KIT_PIN, GPIO_PIN_RESET);

  /*Configure GPIO pin : PA4 */
  GPIO_InitStruct.Pin = ADC_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
  GPIO_InitStruct.Pull = GPIO_NOPULL;


  /*Configure GPIO pins : PA5 */
  GPIO_InitStruct.Pin = LED_UC_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_UC_PORT, &GPIO_InitStruct);


  /*Configure GPIO pins : PA11 */
  GPIO_InitStruct.Pin = LED1_KIT_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED1_KIT_PORT, &GPIO_InitStruct);

  /*Configure GPIO pin : PB15 */
  GPIO_InitStruct.Pin = LED2_KIT_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED2_KIT_PORT, &GPIO_InitStruct);

  /*Configure GPIO pin : PC13 */
  GPIO_InitStruct.Pin = BUTTON_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BUTTON_PORT, &GPIO_InitStruct);

  gpio_status = HAL_OK;
  /* Configuration NVIC for EXTI15_10 */
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 5, 0); // Prioritet i podprioritet
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn); // Omogući prekid


/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();


  if (uart_error_status == USART3_ERROR) {
	  for (;;){
		  /* Led1->uC will be set if USART3 fails with sending or receiving */
		  HAL_GPIO_WritePin(LED_UC_PORT, LED_UC_PIN, GPIO_PIN_SET);
		  HAL_Delay(200);
	  }
  }
  else if (uart_error_status == USART2_ERROR){
	  for (;;){
		  /* Led2->kit will be set if USART2 fails with sending or receiving */
		  HAL_GPIO_WritePin(LED2_KIT_PORT, LED2_KIT_PIN, GPIO_PIN_SET);
		  HAL_Delay(200);
	  }
  }
  else if (uart_error_status = UART4_ERROR || logging == LOGGING_ERROR){
	  for(;;){
		  HAL_GPIO_TogglePin(LED1_KIT_PORT, LED1_KIT_PIN);
		  HAL_Delay(200);
	  }
  }

  else {
	  /*All other errors check call->stack for debbug error*/
	  for (;;);
  }

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
